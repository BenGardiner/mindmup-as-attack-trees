#!/usr/bin/env node

const fs = require('fs');
const D3Node = require('d3-node');
const d3 = require('d3');
const path = require("path");
const yargs = require('yargs');

const argv = yargs
    .usage(`rendermup input.mup`)
    .demand(1)
    .option("w", {
        alias: "width",
        type: "number",
        describe: "The output file width, in pixels",
        default: "1260"
    })
    .option("h", {
        alias: "height",
        type: "number",
        describe: "The output file height, in pixels",
        default: "1550"
    })
    .option("r", {
        alias: "right-justified",
        type: "boolean",
        describe: "render the tree with all leaves at the right (i.e. cluster/dendrogram layout)",
        default: "false"
    })
    .help(false)
    .argv;

const input = fs.readFileSync(argv._[0], 'utf8');
const outputHtmlFilename = path.basename(argv._[0], ".mup") + ".html";
const outputPngFilename = path.basename(argv._[0], ".mup") + ".png";

const styles = `

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

`;
const markup = '<div id="container"><div id="chart"></div></div>';
var options = {selector:'#chart', svgStyles:styles, container:markup, d3Module:d3};

var d3n = new D3Node(options);

///-- start D3 code
//TODO: stop abusing margin.left to compensate for test rendering of top node getting cut off
//TODO: prevent text labels from getting cut-off on the right
var margin = {top: 40, right: 40, bottom: 40, left: 160},
  total_width = argv.width;
  total_height = argv.height;
  width = total_width - margin.left - margin.right,
  height = total_height - margin.top - margin.bottom;

var g = d3n.createSVG()
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .attr("viewBox", "0 0 " + total_width + " " + total_height)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

do_draw = function(json) {
  var root_node = d3.hierarchy(json, function(d) {
    if (typeof d.ideas === "undefined"){ return null; }
    if (typeof d.attr !== "undefined" && typeof d.attr.collapsed !== "undefined" && d.attr.collapsed === true) { return null; }
    //sort(...) orders the ideas the same as the children are ordered in mindmup
    return Object.keys(d.ideas).sort(function(a,b) { return a - b; }).map(key => d.ideas[key]);
  });

  var tree = d3.tree();
  if (argv.r) {
    tree = d3.cluster();
  }
  var tree = tree.size([height, width-160]);

  text_wrap_width = Number.MAX_SAFE_INTEGER;
  var link = g.selectAll(".link")
    .data(tree(root_node).descendants().slice(1))
    .enter().append("path")
      .attr("class", "link")
      .attr("d", function(d) {
        elbow_point = (d.parent.y + 9*(d.y - d.parent.y) / 10)
        if (argv.r) {
          elbow_point = d.parent.y;
        }

        if (d.parent !== null) {
          text_wrap_width = Math.min(text_wrap_width, d.y - d.parent.y);
        }

        return "M" + d.parent.y + "," + d.parent.x
            + "H" + elbow_point + "V" + d.x + "H" + d.y;
      });

  text_wrap_width = 0.9 * text_wrap_width;

  //Wow, this is embarassing. Please look away!
  // 'works' only for 10pt sans-serif, here, when stars are properly aligned
  var approxTextWidth = (function() {
      function charW(w, c) {
          if (c == 'W' || c == 'M') w += 15;
          else if (c == 'w' || c == 'm') w += 12;
          else if (c == 'I' || c == 'i' || c == 'l' || c == 't' || c == 'f') w += 4;
          else if (c == 'r') w += 8;
          else if (c == c.toUpperCase()) w += 12;
          else w += 10;
          return w;
      }

      return function(s) {
          return s.split('').reduce(charW, 0) / 2;
      };
  })();

  function d3TextWrap(text, width) {
      var arrLineCreatedCount = [];
      text.each(function() {
          var text = d3.select(this),
              words = text.text().split(/[ \f\n\r\t\v]+/).reverse(), //Don't cut non-breaking space (\xA0), as well as the Unicode characters \u00A0 \u2028 \u2029)
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1, //Ems
              x = text.attr("x"),
              y = text.attr("y"),
              createdLineCount = 1; //Total line created count
          var textAlign = text.style('text-anchor') || 'left';
          var alignmentBase = text.style('alignment-baseline') || 'baseline';
          var adjusted_width = text.datum().children ? width : width / 2; //leaf nodes only get 1/2 the horizontal space over on the right

          dy = 0;
          x = 0;
          if (textAlign === 'start') {
            x = 8;
          }
          y = 3;
          if (alignmentBase === 'hanging') {
            y = 12;
          }

          var tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
          //noinspection JSHint
          while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (approxTextWidth(line.join(" ")) > adjusted_width && line.length > 1) {
                  line.pop();
                  tspan.text(line.join(" "));
                  line = [word];
                  tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                  ++createdLineCount;
              }
          }

          arrLineCreatedCount.push(createdLineCount); //Store the line count in the array
      });
      return arrLineCreatedCount;
  }

  //TODO: add vertical offset or do 'separation function' magic to keep the labels from overlapping
  var node = g.selectAll(".node")
    .data(root_node.descendants())
    .enter().append("g")
      .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

  node.append("circle")
      .attr("r", 2.5);

  node.append("text")
      .attr("dy", 3)
      .attr("x", function(d) { return d.children ? -8 : 8; })
      .style("text-anchor", function(d) {
          if (d.parent === null) {
            return "start";
          }
          return d.children ? "middle" : "start";
      })
      .style("alignment-baseline", function(d) {
          if (d.data.title === "AND") {
            return "middle";
          }
          return d.children ? "hanging" : "baseline";
      })
      .text(function(d) { return d.data.title; })
      .call(d3TextWrap, text_wrap_width, 0, 0);
};

mindmup_json = JSON.parse(input);

if (typeof mindmup_json.id !== "undefined" && mindmup_json['id'] === "root") { // handle >= 2 mindmup_json
  mindmup_json = mindmup_json['ideas']['1'];
}

do_draw(mindmup_json);

/// -- end D3 code

// create output files
const svg2png = require('svg2png');

fs.writeFile(outputHtmlFilename, d3n.html(), function () {
  console.log('>> Done. Open '+outputHtmlFilename+'" in a web browser');
});

var svgBuffer = new Buffer(d3n.svgString(), 'utf-8');
svg2png(svgBuffer, {width: width*4})
  .then(buffer => fs.writeFile(outputPngFilename, buffer))
  .catch(e => console.error('ERR:', e))
  .then(err => console.log('>> Exported: "'+outputPngFilename+'"'));

