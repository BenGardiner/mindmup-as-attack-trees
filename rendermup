#!/usr/bin/env node

const fs = require('fs');
const D3Node = require('d3-node');
const d3 = require('d3');
const path = require("path");
const yargs = require('yargs');

const argv = yargs
    .usage(`rendermup input.mup`)
    .demand(1)
    .option("w", {
        alias: "width",
        type: "number",
        describe: "The output file width, in pixels",
        default: "1260"
    })
    .option("h", {
        alias: "height",
        type: "number",
        describe: "The output file height, in pixels",
        default: "1550"
    })
    .option("r", {
        alias: "right-justified",
        type: "boolean",
        describe: "render the tree with all leaves at the right (i.e. cluster/dendrogram layout)",
        default: "false"
    })
    .help(false)
    .argv;

const input = fs.readFileSync(argv._[0], 'utf8');
const outputHtmlFilename = path.basename(argv._[0], ".mup") + ".html";
const outputPngFilename = path.basename(argv._[0], ".mup") + ".png";

const styles = `

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

`;
const markup = '<div id="container"><div id="chart"></div></div>';
var options = {selector:'#chart', svgStyles:styles, container:markup, d3Module:d3};

var d3n = new D3Node(options);

///-- start D3 code
//TODO: stop abusing margin.left to compensate for test rendering of top node getting cut off
//TODO: prevent text labels from getting cut-off on the right
var margin = {top: 40, right: 40, bottom: 40, left: 160},
  total_width = argv.width;
  total_height = argv.height;
  width = total_width - margin.left - margin.right,
  height = total_height - margin.top - margin.bottom;

var g = d3n.createSVG()
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
  .attr("viewBox", "0 0 " + total_width + " " + total_height)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

do_draw = function(json) {
  var root_node = d3.hierarchy(json, function(d) {
    if (typeof d.ideas === "undefined"){ return null; }
    if (typeof d.attr !== "undefined" && typeof d.attr.collapsed !== "undefined" && d.attr.collapsed === true) { return null; }
    //sort(...) orders the ideas the same as the children are ordered in mindmup
    return Object.keys(d.ideas).sort(function(a,b) { return a - b; }).map(key => d.ideas[key]);
  });

  var tree = d3.tree();
  if (argv.r) {
    tree = d3.cluster();
  }
  var tree = tree.size([height, width-160]);

  var link = g.selectAll(".link")
    .data(tree(root_node).descendants().slice(1))
    .enter().append("path")
      .attr("class", "link")
      .attr("d", function(d) {
        elbow_point = (d.parent.y + 3*(d.y - d.parent.y) / 4)
        if (argv.r) {
          elbow_point = d.y - 25;
        }

        return "M" + d.parent.y + "," + d.parent.x
            + "H" + elbow_point + "V" + d.x + "H" + d.y;
      });

  //TODO: offset the internal node text by +one-line vertically, or do 'separation function' magic to keep the labels from overlapping
  var node = g.selectAll(".node")
    .data(root_node.descendants())
    .enter().append("g")
      .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

  node.append("circle")
      .attr("r", 2.5);

  node.append("text")
      .attr("dy", 3)
      .attr("x", function(d) { return d.children ? -8 : 8; })
      .style("text-anchor", function(d) { return d.children ? "end" : "start"; })
      .text(function(d) {
        return d.data.title;
      });

};

mindmup_json = JSON.parse(input);

if (typeof mindmup_json.id !== "undefined" && mindmup_json['id'] === "root") { // handle >= 2 mindmup_json
  mindmup_json = mindmup_json['ideas']['1'];
}

do_draw(mindmup_json);

/// -- end D3 code

// create output files
const svg2png = require('svg2png');

fs.writeFile(outputHtmlFilename, d3n.html(), function () {
  console.log('>> Done. Open '+outputHtmlFilename+'" in a web browser');
});

var svgBuffer = new Buffer(d3n.svgString(), 'utf-8');
svg2png(svgBuffer, {width: width*4})
  .then(buffer => fs.writeFile(outputPngFilename, buffer))
  .catch(e => console.error('ERR:', e))
  .then(err => console.log('>> Exported: "'+outputPngFilename+'"'));

