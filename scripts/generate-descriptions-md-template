#!/usr/bin/env python

from mindmup_as_attack_trees import *
import sys,json
import copy
import html2text
from bs4 import BeautifulSoup
import re
import ipdb
import argparse
parser = argparse.ArgumentParser()

def info(type, value, tb):
	ipdb.pm()
#sys.excepthook = info

parser.add_argument("--for-pandoc", action='store_true', help="generate markdown destined for pandoc, disables pandoc-specific markdown tricks. When not specified, the output is tailored for github.")
parser.add_argument("input", help="the mindmup file that will be processed to create the markdown text body")
parser.add_argument('--cuts', nargs='+', help='specify a list of nodes (by title string match) where the tree should be cut-up while rendering', required=False)
parser.add_argument("--only-objectives", action='store_true', help="only generate markdown for the attacker objectives, not the rest of the tree")
parser.add_argument("--no-attack-classification", action='store_true', help="don't emit the sometimes noisy 'attack classification' sections for the attack vectors")
parser.add_argument("--auto-attack-threat", action='store_true', help="create attack threat summaries automatically based on the attacker objective nodes and ignore the text in the node bodies")
parser.add_argument("--mitigations-as-nodes", action='store_true', help="mitigations are separate nodes in this attack tree, search for them and collate them to create the sections for the report")
args = parser.parse_args()

text_maker = html2text.HTML2Text()
text_maker.body_width = 0 #disable random line-wrapping from html2text

tops = list()
seconds = list()

def truncate(node, cuts, first):
	if not first and is_cut(node, cuts) and 'ideas' in node:
		title = node.get('title','')
		parsed_title = re.match(r'(\d+\..*?)\s(.*?)$',title).groups()

		node.update({'title': "%s (%s)" % (parsed_title[1], parsed_title[0])})
		if not 'attr' in node:
			node.update({'attr': dict()})
		node['attr'].update({'collapsed': True})

	for key, value in node.get('ideas', dict()).iteritems():
		truncate(value, cuts, False)

	return node

def get_safe_filename(notsafe):
	safe = notsafe.replace("?", "_").replace("/", "_").replace(",", "_").replace('\'','_').replace('(','_').replace(')','_').replace('  ', ' ')
	return safe[:200] if len(safe) > 200 else safe

def emit_tree_snapshot(title, node):
	global cuts
	global resources

	truncated = truncate(copy.deepcopy(node), cuts, True)

	#TODO: include also the 'theme' from the graphic
	if not resources is None:
		truncated.update({'resources': resources})

	if truncated.get('attr', None) is None:
		truncated.update({'attr': dict()})
	truncated.get('attr').update({ 'theme': 'straightlines'})

	title = get_safe_filename(title)

	f1 = open('%s.mup' % title, 'w')
	f1.write(json.dumps(truncated))
	f1.close()
	return

def do_ideas(depth, cuts, node):
	count = 1
	for value in get_node_children(node):
		add_label(depth+1, cuts, value)
		count = count+1
	return

def is_cut(node, cuts):
	title = node.get('title','')
	for cut in cuts:
		if cut.endswith('.'):
			match_pattern='%s'
		else:
			match_pattern='%s '

		if title.startswith(match_pattern % cut):
			return True
	
	return is_objective(node) or is_subtree(node)

def add_label(depth, cuts, node):
	global tops
	global seconds

	working_title = node.get('title', None)
	if is_cut(node, cuts):
		if is_objective(node):
			#emit the full description
			level = 2
			parsed_title = re.match(r'(\d+\..*?)\s(.*?)$',working_title).groups()
			print("\n\n%s Attacker Objective Node %s (%s)" % ( ('#' * level, parsed_title[1], parsed_title[0])))
			description = get_description(node)
			print("\n%s" % description)
			#deep copy node
			#change node description to "This objective's severity and other details are covered in section *Attack Objective Node %s*, above. Please see that section for more details. In this section we will examine the Attacker Methods and intermediate nodes below it down to the attack vectors in detail.
			new_node = copy.deepcopy(node)
			update_raw_description(new_node, "This objective's severity and other details are covered in section *Attacker Objective Node %s*, above. Please see that section for more details. In this section we will examine the Attacker Methods and intermediate nodes below it down to the attack vectors in detail." % working_title)
			if not args.only_objectives: # don't bother descending the tree in --only-objectives
				seconds.append(new_node)
		else:
			tops.append(node)
		return
	else:
		level = 2

	if node.get('title', None) == 'AND':
		do_ideas(depth, cuts, node)
		return

	if node.get('title', None) == '...':
		do_ideas(depth, cuts, node)
		return

	if is_node_a_reference(node):
		return

	description = get_description(node)

	if is_attack_vector(node):
		print_title_headings_for_attack_vector_node(level, working_title)
		print_other_headings(level, working_title, description)
	else:
		if len(description.strip()) > 0:
			print_title_headings_for_intermediate_node(level, working_title)
			print("\n%s" % description)

	if (not is_collapsed(node)) and (not is_attack_vector(node)):
		do_ideas(depth, cuts, node)
	return

def print_title_headings_for_goal_node(level,title):
	print("\n\n%s Subtree %s" % ('#' * (level), title ))

def print_title_headings_for_intermediate_node(level,title):
	print("\n\n%s Intermediate Node %s" % ('#' * (level), title ))

def print_title_headings_for_attack_vector_node(level,title):
	print("\n\n%s Attack Vector Node %s" % ('#' * (level), title ))

def print_other_headings(level, title, description):
	global evita_tags

	description_lines = description.splitlines()

	classification_heading_found=False
	threat_heading_found=False
	mitigation_heading_found=False
	previous_blank=False
	suppress_this_subsection=False

	if "out of scope".lower() in description.lower():
		#don't emit the 'missing' sections for out of scope nodes
		classification_heading_found=True
		threat_heading_found=True
		mitigation_heading_found=True

	for description_line in description_lines:
		if "# Attack Classification".lower() in description_line.lower() or description_line.strip().lower().endswith("Attack Classification:".lower()):
			classification_heading_found=True
			previous_blank=True
			suppress_this_subsection=False
			if not args.no_attack_classification:
				print("\n%s Attack Classification" % ('#' * (level+1)))
			else:
				suppress_this_subsection=True
		elif "# Attack Threat".lower() in description_line.lower() or description_line.strip().lower().endswith("Attack Threat:".lower()):
			threat_heading_found=True
			previous_blank=True
			suppress_this_subsection=False
			if not args.auto_attack_threat:
				print("\n%s Attack Threat" % ('#' * (level+1)))
			else:
				suppress_this_subsection=True
		elif "# Mitigation Required".lower() in description_line.lower() or description_line.strip().lower().replace("mitigations","mitigation").endswith("Mitigation Required:".lower()):
			mitigation_heading_found=True
			previous_blank=True
			suppress_this_subsection=False
			if not args.mitigations_as_nodes:
				print("\n%s Mitigation Required" % ('#' * (level+1)))
			else:
				suppress_this_subsection=True
		elif description_line.strip().lower().endswith("Description:".lower()):
			suppress_this_subsection=False
			continue # skip Description: lines, all lines are emitted under a 'Attack Description' heading
		elif description_line.strip() == "":
			if not previous_blank:
				print(description_line)
				previous_blank=True
			continue # skip blank lines
		else:
			if not suppress_this_subsection:
				print(description_line)
				previous_blank=False

	if not classification_heading_found and not args.no_attack_classification:
		print("\n%s Attack Classification" % ('#' * (level+1)))
	if args.auto_attack_threat:
		#TODO
		#print("\n%s Attack Threat" % ('#' * (level+1)))
		print
	if args.mitigations_as_nodes:
		#TODO
		#print("\n%s Mitigation Required" % ('#' * (level+1)))
		print

def add_graphic(node, title):
	emit_tree_snapshot(title, node)
	print("\n![*%s Attack Subtree*](%s.png)%s" % (title, get_safe_filename(title), "{ width=100% }" if args.for_pandoc else ""))

def do_tops():
	global tops
	global seconds
	global cuts

	depth = 0
	heading_level = 1
	tops_count = 0
	seconds_heading_done = False

	while len(tops) + len(seconds) > 0:
		if len(tops) > 0:
			node = tops.pop(0)
		else:
			node = seconds.pop(0)

		title = node.get('title', '')

		if tops_count == 0:
			print("\n%s Attack Trees: Attacker Objectives" % ('#' * 1))
			tops_count = tops_count + 1
		else:
			if not seconds_heading_done:
				print("\n\n%s Attack Trees: Attacker Methods Etc." % ('#' * 1))
				print("\n In the attack tree analysis, the attacker methods follow from the objectives and these methods give rise to (many) attack vectors.\n\nIn the sections that follow we will examine the attack methods (the immediate children of the objectives) and the attack paths that can lead to an attacker successfully completing them.")
				seconds_heading_done = True
			print_title_headings_for_goal_node(heading_level, title)

		add_graphic(node, title)
		description = get_description(node)
		print("\n%s" % description)

		do_ideas(depth, cuts, node)
	return

fd_in = open(args.input, 'r')
cuts = args.cuts
if cuts is None:
	cuts = list()

data = json.load(fd_in)
fd_in.close()

resources = None
if 'resources' in data:
	resources = data['resources']
#TODO: capture the theme to transfer it to the subtree snapshots

if 'id' in data and data['id'] == 'root':
	#version 2 mindmup
	tops.append(data['ideas']['1'])
else:
	tops.append(data)

do_tops()

