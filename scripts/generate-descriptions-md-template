#!/usr/bin/env python

import sys,json
import copy
import html2text
from bs4 import BeautifulSoup
import re
import ipdb

def info(type, value, tb):
	ipdb.pm()
#sys.excepthook = info

text_maker = html2text.HTML2Text()
text_maker.body_width = 0 #disable random line-wrapping from html2text

tops = list()
seconds = list()

def truncate(node, cuts, first):
	if not first and is_cut(node, cuts) and 'ideas' in node:
		title = node.get('title','')
		parsed_title = re.match(r'(\d+\..*?)\s(.*?)$',title).groups()

		node.update({'title': "%s (%s)" % (parsed_title[1], parsed_title[0])})
		if not 'attr' in node:
			node.update({'attr': dict()})
		node['attr'].update({'collapsed': True})

	for key, value in node.get('ideas', dict()).iteritems():
		truncate(value, cuts, False)

	return node

def get_safe_filename(notsafe):
	safe = notsafe.replace("?", "_").replace("/", "_").replace(",", "_").replace('\'','_').replace('(','_').replace(')','_').replace('  ', ' ')
	return safe[:200] if len(safe) > 200 else safe

def emit_tree_snapshot(title, node):
	global cuts
	global resources

	truncated = truncate(copy.deepcopy(node), cuts, True)

	#TODO: include also the 'theme' from the graphic
	if not resources is None:
		truncated.update({'resources': resources})

	if truncated.get('attr', None) is None:
		truncated.update({'attr': dict()})
	truncated.get('attr').update({ 'theme': 'straightlines'})

	title = get_safe_filename(title)

	f1 = open('%s.mup' % title, 'w')
	f1.write(json.dumps(truncated))
	f1.close()
	return

def do_ideas(depth, cuts, node):
	count = 1
	for key, value in iter(sorted(node.get('ideas', dict()).iteritems(), key=lambda (k,v): (float(k),v) )):
		add_label(depth+1, cuts, value)
		count = count+1
	return

def is_cut(node, cuts):
	title = node.get('title','')
	for cut in cuts:
		if cut.endswith('.'):
			match_pattern='%s'
		else:
			match_pattern='%s '

		if title.startswith(match_pattern % cut):
			return True
	
	return is_objective(node) or is_subtree(node)

def is_subtree(node):
	raw_description = get_raw_description(node)
	return 'SUBTREE::' in raw_description

def is_objective(node):
	raw_description = get_raw_description(node)
	return 'OBJECTIVE::' in raw_description

def is_riskpoint(node):
	raw_description = get_raw_description(node)
	return 'RISK_HERE::' in raw_description

def is_node_a_reference(node):
	title = node.get('title', '')

	return (not title.find('(*)') == -1) or (not re.search(r'\(\d+\..*?\)', title) is None)

def add_label(depth, cuts, node):
	global tops
	global seconds

	working_title = node.get('title', None)
	if is_cut(node, cuts):
		if is_objective(node):
			#emit the full description
			level = 2
			print("\n\n%s Attacker Objective Node %s" % ( ('#' * level, working_title)))
			description = get_description(node)
			print("\n%s" % description)
			#deep copy node
			#change node description to "This objective's severity and other details are covered in section *Attack Objective Node %s*, above. Please see that section for more details. In this section we will examine the Attacker Methods and intermediate nodes below it down to the attack vectors in detail.
			new_node = copy.deepcopy(node)
			update_raw_description(new_node, "This objective's severity and other details are covered in section *Attacker Objective Node %s*, above. Please see that section for more details. In this section we will examine the Attacker Methods and intermediate nodes below it down to the attack vectors in detail." % working_title)
			seconds.append(new_node)
		else:
			tops.append(node)
		return
	else:
		level = 2

	if node.get('title', None) == 'AND':
		do_ideas(depth, cuts, node)
		return

	if node.get('title', None) == '...':
		do_ideas(depth, cuts, node)
		return

	if is_node_a_reference(node):
		return

	description = get_description(node)

	if len(node.get('ideas', dict())) > 0:
		if len(description.strip()) > 0:
			print_title_headings_for_intermediate_node(level, working_title)
			print("\n%s" % description)
	else:
		print_title_headings_for_attack_vector_node(level, working_title)
		print_other_headings(level, working_title, description)

	collapsed = node.get('attr', dict()).get('collapsed', False)
	if not collapsed:
		do_ideas(depth, cuts, node)
	return

def print_title_headings_for_goal_node(level,title):
	print("\n\n%s Subtree %s" % ('#' * (level), title ))

def print_title_headings_for_intermediate_node(level,title):
	print("\n\n%s Intermediate Node %s" % ('#' * (level), title ))

def print_title_headings_for_attack_vector_node(level,title):
	print("\n\n%s Attack Vector Node %s" % ('#' * (level), title ))


def print_other_headings(level, title, description):
	global evita_tags

	description_lines = description.splitlines()

	classification_heading_found=False
	threat_heading_found=False
	mitigation_heading_found=False
	previous_blank=False

	if "out of scope".lower() in description.lower():
		#don't emit the 'missing' sections for out of scope nodes
		classification_heading_found=True
		threat_heading_found=True
		mitigation_heading_found=True

	for description_line in description_lines:
		if "# Attack Classification".lower() in description_line.lower() or description_line.strip().lower().endswith("Attack Classification:".lower()):
			classification_heading_found=True
			previous_blank=True
			print("\n%s Attack Classification" % ('#' * (level+1)))
		elif "# Attack Threat".lower() in description_line.lower() or description_line.strip().lower().endswith("Attack Threat:".lower()):
			threat_heading_found=True
			previous_blank=True
			print("\n%s Attack Threat" % ('#' * (level+1)))
		elif "# Mitigation Required".lower() in description_line.lower() or description_line.strip().lower().replace("mitigations","mitigation").endswith("Mitigation Required:".lower()):
			mitigation_heading_found=True
			previous_blank=True
			print("\n%s Mitigation Required" % ('#' * (level+1)))
		elif description_line.strip().lower().endswith("Description:".lower()):
			continue # skip Description: lines, all lines are emitted under a 'Attack Description' heading
		elif description_line.strip() == "":
			if not previous_blank:
				print(description_line)
				previous_blank=True
			continue # skip blank lines
		else:
			print(description_line)
			previous_blank=False

	
	if not classification_heading_found:
		print("\n%s Attack Classification" % ('#' * (level+1)))
	if not threat_heading_found:
		print("\n%s Attack Threat" % ('#' * (level+1)))
	if not mitigation_heading_found:
		print("\n%s Mitigation Required" % ('#' * (level+1)))

def add_graphic(node, title):
	emit_tree_snapshot(title, node)
	print("\n![*%s Attack Subtree*](%s.png){ width=100%% }" % (title, get_safe_filename(title)))

def detect_html(text):
	return bool(BeautifulSoup(text, "html.parser").find())

def get_raw_description(node):
	#prefer the mindmup 2.0 'note' to the 1.0 'attachment'
	description = node.get('attr', dict()).get('note', dict()).get('text', '')
	if description is '':
		description = node.get('attr', dict()).get('attachment', dict()).get('content', '')

	return description

def update_raw_description(node, description):
	if not node.get('attr', dict()).get('attachment', dict()).get('content', None) is None:
		node.get('attr', dict()).get('attachment', dict()).update({'content': description})
	else:
		node.get('attr', dict()).get('note', dict()).update({'text': description})

def get_description(node):
	global text_maker

	description = get_raw_description(node) + '\n'

	#TODO: convert special characters e.g. %lt => <
	if detect_html(description):
		description = text_maker.handle(description)

	#remove line breaks between '|' -- to preserve tables in 1.0 mindmups (that end up in multiple <div>)
	description = re.sub(r'\|\n+\|', '|\n|', description, re.M)

	#remove special tags (e.g. SUBTREE:: OBJECTIVE:: EVITA::)
	description = description.replace('SUBTREE::', '').replace('OBJECTIVE::','').replace('RISK_HERE::', '')

	description = re.sub(r'\nEVITA::.*\n', '\n\n', description, re.M)

	#remove trailing whitespace
	description = re.sub(r'\s+$', '\n', description, flags=re.M)

	#remove trailing newlines
	description = re.sub(r'\n+$', '', description)

	#remove leading newlines
	description = re.sub(r'^\n+', '', description)

	return description

def do_tops():
	global tops
	global seconds
	global cuts

	depth = 0
	heading_level = 1
	tops_count = 0
	seconds_heading_done = False

	while len(tops) + len(seconds) > 0:
		if len(tops) > 0:
			node = tops.pop(0)
		else:
			node = seconds.pop(0)

		title = node.get('title', '')

		if tops_count == 0:
			print("\n%s Attack Trees: Attacker Objectives" % ('#' * 1))
			tops_count = tops_count + 1
		else:
			if not seconds_heading_done:
				print("\n\n%s Attack Trees: Attacker Methods Etc." % ('#' * 1))
				print("\n In the attack tree analysis, the attacker methods follow from the objectives and these methods give rise to (many) attack vectors.\n\nIn the sections that follow we will examine the attack methods (the immediate children of the objectives) and the attack paths that can lead to an attacker successfully completing them.")
				seconds_heading_done = True
			print_title_headings_for_goal_node(heading_level, title)

		add_graphic(node, title)
		description = get_description(node)
		print("\n%s" % description)

		do_ideas(depth, cuts, node)
	return

fd_in = open(sys.argv[1], 'r')
cuts = sys.argv[2:]
data = json.load(fd_in)
fd_in.close()

resources = None
if 'resources' in data:
	resources = data['resources']
#TODO: capture the theme to transfer it to the subtree snapshots

if 'id' in data and data['id'] == 'root':
	#version 2 mindmup
	tops.append(data['ideas']['1'])
else:
	tops.append(data)

do_tops()

